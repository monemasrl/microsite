name: "Build and Deploy Microsite"

on:
  workflow_dispatch:
    inputs:
      template:
        description: "Nome template/theme Hugo (es: tpl-b2b, tpl-b2c, tpl-default)"
        required: true
        default: "tpl-default"
      environment:
        description: "Hugo environment"
        required: true
        default: "production"
      zone_id:
        description: "ID della zona DNS su Cloudflare (per record CNAME)"
        required: true
      project_id:
        description: "ID del file config (json|yaml) su S3"
        required: true
      preview:
        description: "Abilita deploy su branch preview (es: 'preview') invece che su main"
        required: false
        default: ""

  # Trigger da API con payload custom (repository_dispatch)
  repository_dispatch:
    types: [build-template]

concurrency:
  group: pages-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      HUGO_VERSION: "latest"        # imposta la tua versione
      HUGO_ENVIRONMENT: "production"
      PROJECT_ID: ""              # ID progetto su S3 (config + content)
      PROVISION_DOMAINS: "false"   # se true, attiva step di provisioning dominio + DNS
      ZONE_ID: ""                   # ID zona DNS per record CNAME
      BASE_THEME: ""                # se usi un tema base comune a più template, specific
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Resolve and validate inputs
        shell: bash
        run: |
          set -euo pipefail

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            TEMPLATE="${{ github.event.inputs.template }}"
            HUGO_ENV="${{ github.event.inputs.environment }}"
            PROJECT_ID="${{ github.event.inputs.project_id }}"
            PROVISION_DOMAINS="${{ github.event.inputs.preview }}" # opzionale, default "false"
            ZONE_ID="${{ github.event.inputs.zone_id }}"
            CONTENT_URL="https://microsite.s3.cubbit.eu/${{ github.event.inputs.project_id }}/content.json"
          else
            TEMPLATE='${{ github.event.client_payload.template }}'
            HUGO_ENV='${{ github.event.client_payload.environment }}'
            PROJECT_ID='${{ github.event.client_payload.project_id }}'
            PROVISION_DOMAINS='${{ github.event.client_payload.preview }}'
            ZONE_ID='${{ github.event.client_payload.zone_id }}'
            CONTENT_URL='https://microsite.s3.cubbit.eu/${{ github.event.client_payload.project_id }}/content.json'
          fi

          for name in TEMPLATE HUGO_ENV PROJECT_ID CONTENT_URL ZONE_ID; do
            val="${!name:-}"
            if [[ -z "$val" || "$val" == "null" ]]; then
              echo "Parametro mancante: $name"
              exit 1
            fi
          done

          echo "TEMPLATE=${TEMPLATE}" >> $GITHUB_ENV
          echo "HUGO_ENV=${HUGO_ENV}" >> $GITHUB_ENV
          echo "PROJECT_ID=${PROJECT_ID}" >> $GITHUB_ENV
          echo "CONTENT_URL=${CONTENT_URL}" >> $GITHUB_ENV
          echo "ZONE_ID=${ZONE_ID}" >> $GITHUB_ENV

      - name: Validate template (whitelist + filesystem)
        shell: bash
        run: |
          set -euo pipefail

          ALLOWED=("under-construction-pro" "under-construction-elegant")
          VALID=0
          for t in "${ALLOWED[@]}"; do [[ "$t" == "${TEMPLATE}" ]] && VALID=1; done
          if [[ $VALID -ne 1 ]]; then
            echo "Template non consentito: ${TEMPLATE}"
            echo "Consentiti: ${ALLOWED[*]}"
            exit 1
          fi

          [[ -d "themes/${TEMPLATE}" ]] || { echo "Tema non trovato: themes/${TEMPLATE}"; exit 1; }

          if [[ -n "${BASE_THEME}" ]]; then
            [[ -d "themes/${BASE_THEME}" ]] || { echo "BASE_THEME non trovato: themes/${BASE_THEME}"; exit 1; }
          fi

      - name: Download remote config + content (public S3)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p data/remote

          curl -fsSL "${CONTENT_URL}" -o data/remote/content.json

          echo "Downloaded:"
          ls -lh data/remote

      - name: Normalize config/content to JSON + generate Hugo content
        shell: bash
        run: |
          set -euo pipefail

          python3 - <<'PY'
          import json, os, re, sys, pathlib

          def detect_format(path: str) -> str:
            # prova “naif” guardando il primo char non-spazio
            s = pathlib.Path(path).read_text(encoding="utf-8", errors="strict").lstrip()
            if not s:
              return "unknown"
            if s[0] in "{[":
              return "json"
            # YAML spesso inizia con '---' o con key:
            if s.startswith("---") or re.match(r"^[A-Za-z0-9_-]+\s*:", s):
              return "yaml"
            return "unknown"

          def load_json(path: str):
            return json.loads(pathlib.Path(path).read_text(encoding="utf-8"))

          def load_yaml(path: str):
            # PyYAML non è garantito: installiamo al volo se serve
            try:
              import yaml  # type: ignore
            except Exception:
              import subprocess
              subprocess.check_call([sys.executable, "-m", "pip", "install", "--quiet", "pyyaml"])
              import yaml  # type: ignore
            return yaml.safe_load(pathlib.Path(path).read_text(encoding="utf-8"))

          def load_any(path: str):
            fmt = detect_format(path)
            if fmt == "json":
              return load_json(path), "json"
            if fmt == "yaml":
              return load_yaml(path), "yaml"
            raise SystemExit(f"Formato non riconosciuto per {path} (usa JSON o YAML)")

          def dump_json(obj, out_path: str):
            pathlib.Path(out_path).write_text(json.dumps(obj, ensure_ascii=False, indent=2) + "\n", encoding="utf-8")

          # 1) Normalizza config/content in JSON in data/remote/
          content, cnt_fmt = load_any("data/remote/content.json")

          dump_json(content, "data/remote/content.json")

          # 2) Genera file markdown in content/ (se presenti)
          pages = content.get("pages", [])
          if not isinstance(pages, list):
            raise SystemExit("content.pages deve essere un array")

          def sanitize_path(p: str) -> str:
            p = p.strip().lstrip("/").replace("\\", "/")
            if ".." in p.split("/"):
              raise SystemExit(f"Path non valido (..): {p}")
            return p

          def yaml_front_matter(meta: dict) -> str:
            # front matter YAML minimale (senza dipendenze)
            lines = ["---"]
            for k, v in meta.items():
              if isinstance(v, bool):
                vv = "true" if v else "false"
                lines.append(f"{k}: {vv}")
              elif v is None:
                continue
              elif isinstance(v, (int, float)):
                lines.append(f"{k}: {v}")
              elif isinstance(v, dict):
                lines.append(f"{k}:")
                for kk, vv in v.items():
                  # string only per semplicità
                  lines.append(f"  {kk}: {json.dumps(str(vv), ensure_ascii=False)}")
              else:
                lines.append(f"{k}: {json.dumps(str(v), ensure_ascii=False)}")
            lines.append("---")
            return "\n".join(lines) + "\n"

          out_root = pathlib.Path("content")
          out_root.mkdir(parents=True, exist_ok=True)

          for page in pages:
            if not isinstance(page, dict):
              raise SystemExit("Ogni elemento di pages deve essere un oggetto")

            path = sanitize_path(page.get("path", ""))
            if not path.endswith(".md"):
              raise SystemExit(f"path deve terminare con .md: {path}")

            title = page.get("title")
            body = page.get("body", "")
            date = page.get("date")
            draft = page.get("draft", False)
            params = page.get("params", {})

            meta = {}
            if title: meta["title"] = title
            if date: meta["date"] = date
            meta["draft"] = bool(draft)
            if isinstance(params, dict) and params:
              meta["params"] = params

            out_path = out_root / path
            out_path.parent.mkdir(parents=True, exist_ok=True)

            out_path.write_text(
              yaml_front_matter(meta) + str(body),
              encoding="utf-8"
            )

          print(f"Generated {len(pages)} markdown files under content/")
          PY

      - name: Setup Hugo
        uses: peaceiris/actions-hugo@v3
        with:
          hugo-version: ${{ env.HUGO_VERSION }}
          extended: true

      - name: Build Hugo
        shell: bash
        run: |
          set -euo pipefail

          if [[ -n "${BASE_THEME}" ]]; then
            THEME_ARG="${TEMPLATE},${BASE_THEME}"
          else
            THEME_ARG="${TEMPLATE}"
          fi

          hugo --minify --environment "${HUGO_ENV}" --theme "${THEME_ARG}"


      # ------------------------------------------------------------
      # Deploy with Wrangler (Pages)
      # ------------------------------------------------------------
      - name: Deploy to Cloudflare Pages (Wrangler)
        uses: cloudflare/wrangler-action@v3
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: >
            pages deploy public
            --project-name=${{ env.PROJECT_ID }}
            --branch=${{ github.ref_name }}

      # ------------------------------------------------------------
      # Provision Pages custom domain + DNS (Cloudflare Zone)
      # Controlled by PROVISION_DOMAINS=true/false
      #
      # Required env vars:
      #   PROVISION_DOMAINS: "true" | "false"
      #   CF_API_TOKEN: Cloudflare API token (Pages write + DNS write + Zone read)
      #   CF_ACCOUNT_ID: Cloudflare account id
      #   PROJECT_ID: Pages project name
      #   ZONE_NAME: DNS zone name (e.g. cliente.it)
      #   CUSTOM_DOMAIN: full domain to attach (e.g. www.cliente.it)
      #
      # Optional:
      #   PAGES_DEV_TARGET: defaults to "${PROJECT_ID}.pages.dev"
      # ------------------------------------------------------------
    #   - name: Provision Pages Custom Domain (optional)
    #     if: ${{ env.PROVISION_DOMAINS == 'true' }}
    #     shell: bash
    #     env:
    #       CF_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
    #       CF_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
    #       PROJECT_ID: ${{ env.PROJECT_ID }}        # o usa un'altra env
    #       ZONE_NAME: ${{ env.ZONE_NAME }}               # es: "cliente.it"
    #       CUSTOM_DOMAIN: ${{ env.CUSTOM_DOMAIN }}       # es: "www.cliente.it"
    #       PAGES_DEV_TARGET: ${{ env.PAGES_DEV_TARGET }} # opzionale
    #     run: |
    #       set -euo pipefail

    #       need() { if [[ -z "${!1:-}" || "${!1}" == "null" ]]; then echo "Missing env: $1"; exit 1; fi; }
    #       need CF_API_TOKEN
    #       need CF_ACCOUNT_ID
    #       need PROJECT_ID
    #       need ZONE_NAME
    #       need CUSTOM_DOMAIN

    #       if [[ -z "${PAGES_DEV_TARGET:-}" || "${PAGES_DEV_TARGET}" == "null" ]]; then
    #         PAGES_DEV_TARGET="${PROJECT_ID}.pages.dev"
    #       fi

    #       api() {
    #         # usage: api METHOD URL [JSON]
    #         local method="$1"; shift
    #         local url="$1"; shift
    #         local data="${1:-}"
    #         if [[ -n "$data" ]]; then
    #           curl -fsS -X "$method" "$url" \
    #             -H "Authorization: Bearer ${CF_API_TOKEN}" \
    #             -H "Content-Type: application/json" \
    #             --data "$data"
    #         else
    #           curl -fsS -X "$method" "$url" \
    #             -H "Authorization: Bearer ${CF_API_TOKEN}"
    #         fi
    #       }

    #       echo "==> Resolve Zone ID for ${ZONE_NAME}"
    #       ZONE_ID=$(
    #         api GET "https://api.cloudflare.com/client/v4/zones?name=${ZONE_NAME}" \
    #         | jq -r '.result[0].id // empty'
    #       )
    #       if [[ -z "$ZONE_ID" ]]; then
    #         echo "Zone not found or not accessible: ${ZONE_NAME}"
    #         exit 1
    #       fi
    #       echo "ZONE_ID=${ZONE_ID}"

    #       echo "==> Ensure Pages project has custom domain: ${CUSTOM_DOMAIN}"
    #       HAS_DOMAIN=$(
    #         api GET "https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/pages/projects/${PROJECT_ID}/domains" \
    #         | jq -r --arg d "${CUSTOM_DOMAIN}" '[.result[]? | select(.name == $d)] | length'
    #       )

    #       if [[ "$HAS_DOMAIN" == "0" ]]; then
    #         api POST "https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/pages/projects/${PROJECT_ID}/domains" \
    #           "{\"name\":\"${CUSTOM_DOMAIN}\"}" >/dev/null
    #         echo "Added domain to Pages: ${CUSTOM_DOMAIN}"
    #       else
    #         echo "Domain already present on Pages: ${CUSTOM_DOMAIN}"
    #       fi

    #       echo "==> Upsert CNAME: ${CUSTOM_DOMAIN} -> ${PAGES_DEV_TARGET}"
    #       CNAME_JSON=$(api GET "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records?type=CNAME&name=${CUSTOM_DOMAIN}")
    #       CNAME_ID=$(echo "$CNAME_JSON" | jq -r '.result[0].id // empty')
    #       CNAME_CONTENT=$(echo "$CNAME_JSON" | jq -r '.result[0].content // empty')

    #       if [[ -z "$CNAME_ID" ]]; then
    #         api POST "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records" \
    #           "{
    #             \"type\":\"CNAME\",
    #             \"name\":\"${CUSTOM_DOMAIN}\",
    #             \"content\":\"${PAGES_DEV_TARGET}\",
    #             \"ttl\":1,
    #             \"proxied\":true
    #           }" >/dev/null
    #         echo "Created CNAME"
    #       else
    #         if [[ "$CNAME_CONTENT" != "$PAGES_DEV_TARGET" ]]; then
    #           api PUT "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records/${CNAME_ID}" \
    #             "{
    #               \"type\":\"CNAME\",
    #               \"name\":\"${CUSTOM_DOMAIN}\",
    #               \"content\":\"${PAGES_DEV_TARGET}\",
    #               \"ttl\":1,
    #               \"proxied\":true
    #             }" >/dev/null
    #           echo "Updated CNAME"
    #         else
    #           echo "CNAME already correct"
    #         fi
    #       fi

    #       echo "==> Fetch Pages domain status + validation data"
    #       get_domain() {
    #         api GET "https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/pages/projects/${PROJECT_ID}/domains/${CUSTOM_DOMAIN}"
    #       }

    #       DOM_JSON="$(get_domain)"
    #       TXT_NAME=$(echo "$DOM_JSON" | jq -r '.result.validation_data.txt_name // empty')
    #       TXT_VALUE=$(echo "$DOM_JSON" | jq -r '.result.validation_data.txt_value // empty')

    #       if [[ -n "$TXT_NAME" && -n "$TXT_VALUE" ]]; then
    #         echo "==> Upsert TXT validation: ${TXT_NAME}"

    #         TXT_JSON=$(api GET "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records?type=TXT&name=${TXT_NAME}")
    #         TXT_ID=$(echo "$TXT_JSON" | jq -r '.result[0].id // empty')
    #         TXT_CONTENT=$(echo "$TXT_JSON" | jq -r '.result[0].content // empty')

    #         if [[ -z "$TXT_ID" ]]; then
    #           api POST "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records" \
    #             "{
    #               \"type\":\"TXT\",
    #               \"name\":\"${TXT_NAME}\",
    #               \"content\":\"${TXT_VALUE}\",
    #               \"ttl\":1
    #             }" >/dev/null
    #           echo "Created TXT validation record"
    #         else
    #           if [[ "$TXT_CONTENT" != "$TXT_VALUE" ]]; then
    #             api PUT "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records/${TXT_ID}" \
    #               "{
    #                 \"type\":\"TXT\",
    #                 \"name\":\"${TXT_NAME}\",
    #                 \"content\":\"${TXT_VALUE}\",
    #                 \"ttl\":1
    #               }" >/dev/null
    #             echo "Updated TXT validation record"
    #           else
    #             echo "TXT validation already correct"
    #           fi
    #         fi
    #       else
    #         echo "No TXT validation required (or not provided by API)."
    #       fi

    #       echo "==> Wait for Pages domain to become active (max ~5 min)"
    #       STATUS=""
    #       for i in $(seq 1 30); do
    #         DOM_JSON="$(get_domain)"
    #         STATUS=$(echo "$DOM_JSON" | jq -r '.result.status // empty')
    #         echo "Status: ${STATUS} (try ${i}/30)"
    #         if [[ "$STATUS" == "active" ]]; then
    #           echo "Domain is active."
    #           exit 0
    #         fi
    #         sleep 10
    #       done

    #       echo "Domain did not become active in time. Last status: ${STATUS}"
    #       echo "$DOM_JSON" | jq .
    #       exit 1

    #   - name: Crea/Aggiorna Record DNS CNAME
    #     # Utilizziamo l'action dedicata ai record DNS
    #     uses: cloudflare/python-cloudflare-zp@v1.0.1
    #     with:
    #       auth_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
    #       zone_id: ${{ env.ZONE_ID }}
    #       name: "@" # Oppure il sottodominio se presente nel payload
    #       type: "CNAME"
    #       content: "${{ env.PROJECT_ID }}.pages.dev"
    #       proxied: true